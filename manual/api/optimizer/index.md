# Методы класса Optimizer

Назад: Прочие методы • К началу: Документация • Далее: Стандартные константы

Содержание
addTemplate
getTemplate
executeTemplate
processTemplate
addBundles
getBundles
getBundlesPlugins
executeBundles
clearCache
processFileCache
clearFileCache
Главное назначение класса Optimizer − ускорение работы проекта на PHPC. Достигается это за счет кеширования данных: кеширования скомпилированных шаблонов, кеширования собранных в группы пакетов, а также файлового кеширования произвольных данных. Кеширование организовано по принципу "генерации по запросу" − кеш наполняется постепенно, по мере востребованности данных. Как только в исходных данных происходят какие-либо изменения − кеш полностью очищается. Это позволяет содержать кешированные данными всегда актуальными без трудоемкого учета зависимостей, и избежать перегрузки сервера при генерации данных.

Экземпляр класса Optimizer создается в движке автоматически и доступен через глобальную переменную $optimizer. В пакетах эта переменная доступна автоматически, ее не нужно никак объявлять. В функциях и методах классов ее нужно предварительно объявить командой:

global $optimizer;
Рассмотрим методы класса более подробно.

addTemplate

template_handle addTemplate ( int styleid, string name, string content )

Метод добавляет новый скомпилированный шаблон в кеш. Идентификатор стиля и имя шаблона передаются параметрами styleid и name, скомпилированный код шаблона − параметром content. После добавления данных в таблицу cachetemplates, метод возвращает "хэндл" шаблона (ассоциативный массив с данными добавленной записи) в качестве результата. Это значение можно впоследствии передать методу executeTemplate.

getTemplate

template_handle getTemplate ( int styleid, string name )

Метод пытается прочитать скомпилированный шаблон из кеша. Идентификатор стиля и имя шаблона передаются параметрами styleid и name. Метод возвращает либо хэндл шаблона, либо false, если шаблон в кеше отсутствует.

executeTemplate

void executeTemplate ( template_handle handle, array scope )

Метод выполняет скомпилированный шаблон, данные которого передаются параметром handle. В качестве области видимости шаблона, или списка доступных переменных, используется значение ассоциативного массива scope. Метод не возвращает результата, поскольку шаблон, выполняясь, просто выводит окончательный HTML-текст функциями echo. Если вам нужно сохранить результат работы шаблона в переменной − используйте функции для управления буфером вывода.

Пример:

// Использование методов addTemplate/getTemplate/executeTemplate
// 1. Имя шаблона и список переменных
$name="sampleTemplate";
$scope=array(
  "username"=>"John Jackson",
  "email"=>"johnjackson@gmail.com",
  "activation"=>1234567890);
// 2. Пытаемся прочитать уже готовый шаблон из кеша
$styleid=$compiler->style["id"];
$handle=$optimizer->getTemplate($styleid,$name);
// 3. Если не получилось − собираем шаблон заново
// и сохраняем в кеше, для следующего раза
if(!$handle) {
  $content=$compiler->compileTemplate($name);
  $handle=$optimizer->addTemplate($styleid,$name,$content);
}
// 4. Теперь можно смело выполнять шаблон
// Обратите внимание, что список переменных понадобился только сейчас
$optimizer->executeTemplate($handle,$scope);
processTemplate

void processTemplate ( string content, array scope )

Метод является упрощенной версией метода executeTemplate. Он также запускает и выполняет скомпилированный шаблон PHPC с передачей ему списка доступных переменных (параметр scope), но, во-первых, ему передается не полный "хэндл" шаблона, а только его скомпилированный текст (параметр content), а во-вторых, он не выполняет никакого кеширования. Используйте этот метод, если вы пользуетесь шаблонизатором не только для обычных шаблонов PHPC, но и для своих нужд (например, для отображения статей со сложным синтаксисом, типа Wiki), при этом вам удобнее организовать кеширование данных своими средствами.

Как и метод executeTemplate, данный метод не возвращает результата, поскольку шаблон, выполняясь, просто выводит окончательный HTML-текст функциями echo. Если вам нужно сохранить результат работы шаблона в переменной − используйте функции для управления буфером вывода.

Пример:

// 1. Имя шаблона и список переменных
$name="sampleTemplate";
$scope=array(
  "username"=>"John Jackson",
  "email"=>"johnjackson@gmail.com",
  "activation"=>1234567890);
// 2. Компиляция шаблона
$content=$compiler->compileTemplate($name);
// 3. Выполнение шаблона с передачей ему переменных
// Учтите, что скомпилированный текст нигде не кешируется,
// поэтому такой вариант может оказаться неэффективным
$optimizer->processTemplate($content,$scope);
addBundles

bundle_handle addBundles ( int styleid, array names, bundle_compilation compilation )

Метод добавляет новую группу пакетов в кеш. Идентификатор стиля передается параметром styleid, список имен пакетов, входящих в группу, передается массивом names. Кроме того, методу требуется указать данные о группе пакетов параметром compilation, который имеет вид ассоциативного массива с ключами content и plugins − PHP-код группы пакетов и массив со списком подключаемых плагинов, соответственно.

После добавления данных в таблицу cachebundles, метод возвращает "хэндл" группы (ассоциативный массив с данными добавленной записи) в качестве результата. Это значение можно впоследствии передать методам getBundlesPlugins и executeBundles.

getBundles

bundle_handle getBundles ( int styleid, array names )

Метод пытается прочитать группу пакетов из кеша. Идентификатор стиля и список имен пакетов, входящих в группу, передаются параметрами styleid и names. Метод возвращает либо хэндл группы, либо значение false, если группа в кеше отсутствует.

getBundlesPlugins

array getBundlesPlugins ( bundle_handle handle )

Метод возвращает список плагинов, подключаемых группой пакетов. Хэндл группы передается параметром handle. Результат имеет вид обычного массива, если для работы пакетов не требуется подключение плагинов − метод возвращает пустой массив.

executeBundles

array executeBundles ( bundle_handle handle, array scope )

Метод выполняет группу пакетов, данные которой передаются параметром handle. В качестве списка переменных, проинициализированных заранее и доступных в пакетах (к ним относятся такие переменные, как $currentStyle, $currentSession и $currentPage), используется значение ассоциативного массива scope. После выполнения пакетов метод возвращает список всех созданных переменных, включая те, что были переданы методу изначально. Эти переменные впоследствии передаются в шаблон.

Пример:

// Использование методов addBundles/getBundles/executeBundles
// 1. Список пакетов и начальный набор переменных
$names=array("general","generalUsers");
$scope=array("currentPage"=>$compiler->page);
// 2. Пытаемся прочитать уже готовую группу из кеша
$styleid=$compiler->style["id"];
$handle=$optimizer->getBundles($styleid,$names);
// 3. Если не получилось − собираем группу заново
// и сохраняем в кеше, для следующего раза
if(!$handle) {
  $compilation=$compiler->compileBundles($names);
  $handle=$optimizer->addBundles($styleid,$names,$compilation);
}
// 4. Теперь можно выполнять пакеты и сохранять полученные данные
$variables=$optimizer->executeBundles($handle,$scope);
clearCache

void clearCache ( [bool strict] )

Метод очищает кеш компилятора, хранящийся в таблицах cachetemplates и cachebundles. Как правило, вызывать этот метод вручную нет необходимости, т.к. при редактировании шаблонов или пакетов в панели управления, он вызывается автоматически. Но если вы вносите какие-либо изменения в тексты шаблонов или пакетов напрямую, а не через панель управления − не забудьте вызвать данный метод, чтобы изменения вошли в силу.

Для того, чтобы создание новых шаблонов и пакетов (например, при инсталляции нового модуля) происходила быстрее, метод очищает кеш только один раз в течение жизни скрипта. Все последующие попытки очистить кеш в пределах того же HTTP-запроса будут проигнорированы. В большинстве случаев этого вполне достаточно, поскольку кеш наполняется данными только во фронтальной части сайта, при отображении страниц, а очищается только в панели управления. Но если вам необходимо, чтобы кеш был обязательно очищен при вызове метода, укажите значение true в качестве необязательного параметра strict.

По умолчанию данный метод очищает только кеш компилятора, то есть таблицы cachetemplates и cachebundles. Если вам нужно, чтобы очистка кеша дополнительно затрагивала другие таблицы − переопределите константу CompilerCacheTables. Кроме того, если вы хотите, чтобы очистка кеша компилятора автоматически приводила к очистке также и файлового кеша PHPC − измените значение константы CompilerCacheCombined на true.

Пример:

// Принудительная очистка кеша компилятора
$optimizer->clearCache();
processFileCache

mixed processFileCache ( string name, int time, callback callback [, array params] )

Метод предназначен для файлового кеширования данных. Идея заключается в следующем: вы пишете функцию или метод класса, который выбирает и обрабатывает данные из таблиц, либо выполняет другие ресурсоемкие действия. Затем в той части приложения, где требуются эти данные, вместо того, чтобы вызывать эту функцию или метод класса напрямую, вы вызываете метод processFileCache, передав ему имя вашей функции или метода в качестве параметра callback. Метод processFileCache берет на себя всю работу по кешированию ваших данных, и "медленная" функция или метод будут вызваны только в случае необходимости, в противном случае будут загружены данные из кеша. В любом случае метод вернет нужные вам данные. Это очень удобно.

Методу необходимо указать имя файла (без расширения), под которым кешированные данные будут сохранены в каталоге cache. Это имя, которое можно также назвать идентификатором кеша, передается параметром name. Также в качестве параметра time следует указать интервал, в течение которого кешированные данные считаются валидными. Когда этот интервал истечет − "медленная" функция или метод будут вызваны повторно, и кеш будет обновлен свежими данными, вновь на указанный вами временной интервал.

Функция или метод, которая вычисляет и возвращает собственно кешируемые данные, передается параметром callback. Если речь идет о функции − просто укажите ее название, обычной строковой константой. Если речь идет о методе класса − укажите в качестве значения параметра массив из двух строковых значений, название класса и название метода соответственно.

Наконец, если ваша функция или метод требует подачи на вход одного или нескольких параметров, перечислите значения этих параметров в необязательном параметре params. Он должен иметь вид обычного массива.

Пример:

// Функция, результат которой нужно закешировать
function getStatistics()
{
  global $database;
  return array(
    "totalProducts"=>$database->getLinesCount("products"),
    "totalNewProducts"=>$database->getLinesCount("products","new=1"),
    "totalCheapProducts"=>$database->getLinesCount("products","price<100"),
    "averagePrice"=>$database->getLinesFunction("products","AVG(price)"));
}

// Кешируем данные на 1 час
$time=OneHour;
// Что конкретно мы кешируем
$callback="getStatistics";
// Теперь данные статистики можно быстро получить так:
$statistics=$optimizer->processFileCache("shopstats",$time,$callback);
clearFileCache

void clearFileCache ( [string mask] )

Метод очищает файловый кеш PHPC, то есть удаляет все содержимое каталога cache. Используйте данный метод в случаях, когда вы используете файловый кеш (при помощи метода processFileCache) для временного хранения данных, и эти данные были изменены. После удаления файлового кеша он будет автоматически обновлен в тот момент, когда кешированные данные потребуются снова.

По умолчанию метод удаляет все кешированные данные, то есть все файлы в каталоге cache. Если вы хотите удалить только часть данных, укажите значение маски для удаления в качестве необязательного параметра mask. Маска указывается в виде строки − одно или несколько имен, использованных для кеширования, через запятую, плюс можно использовать символ звездочки в качестве "дикого" символа. Будут удалены только те файлы, которые соответствуют маске.

Пример:

// Очистка файлового кеша (полностью)
$optimizer->clearFileCache();

// Очистка файлового кеша (только данные магазина и галереи)
$optimizer->clearFileCache("shop*,gallery");

Назад: Прочие методы • К началу: Документация • Далее: Стандартные константы