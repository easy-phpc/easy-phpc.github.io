# Методы для формирования условий

Назад: Работа с таблицами в целом • К началу: Документация • Далее: Методы для экспорта и импорта данных

Содержание
getListCondition
getSearchCondition
getSearchSetCondition
getRangeCondition
getListOrder
Далее перечислены методы класса Database, предназначенные для формирования условий по правилам синтаксиса SQL. Все нижеприведенные методы возвращают строку, которую можно использовать либо в качестве параметра conditions для любого метода выборки данных, либо для формирования более сложных условий.

getListCondition

string getListCondition ( string field, mixed values [, bool istext] )

Метод предназначен для формирования условия типа "значение поля входит в указанный набор". Например, для поля id и набора значений (10,20,30) метод сформирует условие "id IN (10,20,30)". Метод удобен тем, что правильно обрабатывает ситуацию "пустой набор значений" (в этом случае метод возвращает заведомо ложное условие "0"), а также корректно обрабатывает различные типы данных и исключительные ситуации. Рекомендуется пользоваться этим методом вместо того, чтобы формировать подобные условия вручную.

Параметр field означает имя поля, для которого будет сформировано условие. Параметром values передается набор значений − это может быть любой скалярный тип или массив. Метод генерирует адекватное условие вне зависимости от типа, причем по умолчанию набор значений автоматически приводится к целочисленному типу из соображений безопасности. Если вам нужно сформировать условие для строкового поля, и в качестве набора значений вы передаете методу массив строк − укажите необязательному параметру istext значение true. В этом случае значения будут обработаны функцией slashes, то есть экранированы.

Пример:

$condition=$database->getListCondition("id",array(10,20,30));
echo $condition; // id IN (10,20,30)

$condition=$database->getListCondition("id",array(10));
echo $condition; // id=10

$condition=$database->getListCondition("id",array());
echo $condition; // 0

$condition=$database->getListCondition("id",array("red","green"),true);
echo $condition; // id IN ('red','green') 
getSearchCondition

string getSearchCondition ( string field, string value [, bool wholeword] )

Метод предназначен для формирования условия типа "указанная подстрока содержится в поле". Например, для поля title и подстроки "apple" метод сформирует условие "title LIKE '%apple%'". Метод удобен тем, что правильно обрабатывает ситуацию "подстрока не указана" (в этом случае метод возвращает заведомо ложное условие "0") а также корректно экранирует все служебные символы, которые могут оказаться в подстроке, такие, как апостроф, подчеркивание или процент. Кроме того, метод поддерживает возможность поиска только слов целиком.

Параметр field означает имя поля, для которого будет сформировано условие. Параметром value задается подстрока, по которой будет проводится поиск (помните, данный метод не выполняет никакого поиска, он лишь формирует строку с SQL-условием!). Наконец, если указать необязательному параметру wholeword значение true, условие будет дополнено таким образом, что условие будет находить только слова целиком, но не фрагменты слов.

Следует отметить, что для формирования условия используются стандартные операторы LIKE и (в случае поиска по словам целиком) REGEXP. Эти операторы не могут опираться на индексы, так что в случае большого объема данных эти условия могут работать медленно.

Пример:

$condition=$database->getSearchCondition("title","O'Brian");
echo $condition; // title LIKE '%O\'Brian%'

$condition=$database->getSearchCondition("title","Слеши\экранируются!");
echo $condition; // title LIKE '%Слеши\\\\экранируются!%'

$condition=$database->getSearchCondition("title","");
echo $condition; // 0 
getSearchSetCondition

string getSearchSetCondition ( string field, mixed value [, string separator] )

В некоторых случаях бывает удобно в поле одной таблицы хранить набор ссылок на записи из другой таблицы. Например, в таблице комплектаций, в поле "список товаров", хранить перечень ID товаров, входящих в эту комплектацию, перечисленных через запятую. Такой подход позволяет не вводить лишние таблицы и упростить выборки, а также хранить ссылки в упорядоченном виде.

Но возникает проблема поиска по такому полю, то есть для нашего примера − поиска всех комплектаций, в которых содержится заданный товар. Другими словами, по известному ID товара нужно найти все записи основной таблицы, у которых в поле "список товаров" содержится это значение ID. Обычный поиск по подстроке тут не годится, так как значение может совпасть частично, например, при поиске товара с ID=10 в результат может попасть комплектация, содержащая товар с ID=105 или ID=210.

Данный метод предназначен для формирования условия типа "указанное значение содержится в наборе, хранящемся в строковом поле". Он также использует оператор LIKE, но таким образом, что значение сравниваются с содержимым поля корректно, с учетом символа-разделителя (по умолчанию это запятая) и пограничных ситуаций. Единственное условие − символ-разделитель не должен содержаться в значении, по которому производится поиск.

Параметр field означает имя поля, для которого будет сформировано условие. Параметром value задается поисковое значение. Если в качестве разделителя у вас выступает символ или строка, отличная от запятой, укажите ее в качестве необязательного параметра separator. Учтите, что возвращаемое условие, как и у предыдущего метода, неспособно опираться на индекс, поэтому на больших объемах данных рекомендуется пользоваться другими методами (например, индексом FULLTEXT).

Пример:

// Поиск всех комплектаций, в которые входит заданный товар
$productid=10;
// Сначала формируем условие для поиска
$condition=$database->getSearchSetCondition("productlist",$productid);
echo $condition; // CONCAT(',',productlist,',') LIKE '%,10,%'
// Теперь можно найти нужные комплектации
$shipments=$database->getLines("shipments",$condition);
// Можно найти и все комплектации, в которые данный товар НЕ входит
$shipments=$database->getLines("shipments","NOT($condition)");
getRangeCondition

string getRangeCondition ( string field, mixed value )

Метод предназначен для формирования условия типа "числовое поле входит в указанный диапазон". Например, для поля price и диапазона "3000-5000" метод сформирует условие "price>=3000 AND price<=5000". Название поля передается параметром field, значение или диапазон значений − параметром value. Кроме указанного выше формата, метод поддерживает открытые диапазоны ("3000-" или "-+5000"), а также обычное указание точных значений. Поддерживаются как целочисленные, так и вещественные типы.

Пример:

$condition=$database->getRangeCondition("price","3000-5000");
echo $condition; // price>=3000 AND price<=5000

$condition=$database->getRangeCondition("price","3000-");
echo $condition; // price>=3000

$condition=$database->getRangeCondition("price","5000");
echo $condition; // price=5000 
getListOrder

string getListOrder ( string field, mixed values [, bool istext] )

Метод предназначен для формирования сложного порядка выборки. Аргументы у этого метода такие же, как и у метода getListCondition, и они обычно используются в связке. Полученную строку можно передать в качестве параметра order методу getOrderedLines или getOrderedLinesRange, в результате чего выбранные данные будут отсортированы согласно порядку, указанному параметром values.

Пример:

// Требуется выбрать набор товаров из базы, причем именно в указанном порядке
$productids=array(90,35,84,68,31,29,24);
// Подготавливаем условие выборки
$conditions=$database->getListCondition("id",$productids);
// Подготавливаем порядок выборки
$order=$database->getListOrder("id",$productids);
// Делаем выборку. Товары будут отсортированы согласно массиву $productids
$products=$database->getOrderedLines("products",$order,$conditions);

Назад: Работа с таблицами в целом • К началу: Документация • Далее: Методы для экспорта и импорта данных